--- include/llvm/ADT/Triple.h
+++ include/llvm/ADT/Triple.h
@@ -106,6 +106,7 @@
 
     GNU,
     GNUEABI,
+    ANDROIDEABI,
     EABI,
     MachO
   };
--- lib/ExecutionEngine/JIT/Intercept.cpp
+++ lib/ExecutionEngine/JIT/Intercept.cpp
@@ -66,7 +66,11 @@
     sys::DynamicLibrary::AddSymbol("lstat", (void*)(intptr_t)lstat);
     sys::DynamicLibrary::AddSymbol("stat64", (void*)(intptr_t)stat64);
     sys::DynamicLibrary::AddSymbol("\x1stat64", (void*)(intptr_t)stat64);
+#ifdef ANDROID	/* no large file support */
+    sys::DynamicLibrary::AddSymbol("\x1open64", (void*)(intptr_t)open);
+#else
     sys::DynamicLibrary::AddSymbol("\x1open64", (void*)(intptr_t)open64);
+#endif
     sys::DynamicLibrary::AddSymbol("\x1lseek64", (void*)(intptr_t)lseek64);
     sys::DynamicLibrary::AddSymbol("fstat64", (void*)(intptr_t)fstat64);
     sys::DynamicLibrary::AddSymbol("lstat64", (void*)(intptr_t)lstat64);
--- lib/ExecutionEngine/MCJIT/Intercept.cpp
+++ lib/ExecutionEngine/MCJIT/Intercept.cpp
@@ -66,7 +66,11 @@
     sys::DynamicLibrary::AddSymbol("lstat", (void*)(intptr_t)lstat);
     sys::DynamicLibrary::AddSymbol("stat64", (void*)(intptr_t)stat64);
     sys::DynamicLibrary::AddSymbol("\x1stat64", (void*)(intptr_t)stat64);
+#ifdef ANDROID	/* no large file support */
+    sys::DynamicLibrary::AddSymbol("\x1open64", (void*)(intptr_t)open);
+#else
     sys::DynamicLibrary::AddSymbol("\x1open64", (void*)(intptr_t)open64);
+#endif
     sys::DynamicLibrary::AddSymbol("\x1lseek64", (void*)(intptr_t)lseek64);
     sys::DynamicLibrary::AddSymbol("fstat64", (void*)(intptr_t)fstat64);
     sys::DynamicLibrary::AddSymbol("lstat64", (void*)(intptr_t)lstat64);
--- lib/Support/DynamicLibrary.cpp
+++ lib/Support/DynamicLibrary.cpp
@@ -160,7 +160,7 @@
 // On linux we have a weird situation. The stderr/out/in symbols are both
 // macros and global variables because of standards requirements. So, we
 // boldly use the EXPLICIT_SYMBOL macro without checking for a #define first.
-#if defined(__linux__)
+#if defined(__linux__) && !defined(ANDROID)	/* but not Android */
   {
     EXPLICIT_SYMBOL(stderr);
     EXPLICIT_SYMBOL(stdout);
--- lib/Support/PathV2.cpp
+++ lib/Support/PathV2.cpp
@@ -513,9 +513,9 @@
   DefaultResult = "C:\\TEMP";
 #else
   if (erasedOnReboot)
-    DefaultResult = "/tmp";
+    DefaultResult = "/cache";
   else
-    DefaultResult = "/var/tmp";
+    DefaultResult = "/cache";
 #endif
   result.append(DefaultResult, DefaultResult + strlen(DefaultResult));
 }
--- lib/Support/Triple.cpp
+++ lib/Support/Triple.cpp
@@ -127,6 +127,7 @@
   case UnknownEnvironment: return "unknown";
   case GNU: return "gnu";
   case GNUEABI: return "gnueabi";
+  case ANDROIDEABI: return "androideabi";
   case EABI: return "eabi";
   case MachO: return "macho";
   }
@@ -393,6 +394,8 @@
 Triple::EnvironmentType Triple::ParseEnvironment(StringRef EnvironmentName) {
   if (EnvironmentName.startswith("eabi"))
     return EABI;
+  else if (EnvironmentName.startswith("androideabi"))
+    return ANDROIDEABI;
   else if (EnvironmentName.startswith("gnueabi"))
     return GNUEABI;
   else if (EnvironmentName.startswith("gnu"))
--- lib/Support/Unix/Path.inc
+++ lib/Support/Unix/Path.inc
@@ -66,6 +66,11 @@
 # undef HAVE_MKDTEMP
 #endif
 
+// Put in a hack for Android which implements mkdtemp but does not declare it.
+#ifdef ANDROID
+extern "C" char *mkdtemp(char *path);
+#endif
+
 namespace {
 inline bool lastIsSlash(const std::string& path) {
   return !path.empty() && path[path.length() - 1] == '/';
@@ -131,7 +136,7 @@
 #if defined(HAVE_MKDTEMP)
   // The best way is with mkdtemp but that's not available on many systems,
   // Linux and FreeBSD have it. Others probably won't.
-  char pathname[] = "/tmp/llvm_XXXXXX";
+  char pathname[] = "/cache/llvm_XXXXXX";
   if (0 == mkdtemp(pathname)) {
     MakeErrMsg(ErrMsg,
                std::string(pathname) + ": can't create temporary directory");
@@ -144,7 +149,7 @@
   // mktemp because of mktemp's inherent security and threading risks. We still
   // have a slight race condition from the time the temporary file is created to
   // the time it is re-created as a directoy.
-  char pathname[] = "/tmp/llvm_XXXXXX";
+  char pathname[] = "/cache/llvm_XXXXXX";
   int fd = 0;
   if (-1 == (fd = mkstemp(pathname))) {
     MakeErrMsg(ErrMsg,
@@ -165,7 +170,7 @@
   // implementation of mktemp(3) and doesn't follow BSD 4.3's lead of replacing
   // the XXXXXX with the pid of the process and a letter. That leads to only
   // twenty six temporary files that can be generated.
-  char pathname[] = "/tmp/llvm_XXXXXX";
+  char pathname[] = "/cache/llvm_XXXXXX";
   char *TmpName = ::mktemp(pathname);
   if (TmpName == 0) {
     MakeErrMsg(ErrMsg,
@@ -191,7 +196,7 @@
   char pathname[MAXPATHLEN];
   do {
     num++;
-    sprintf(pathname, "/tmp/llvm_%010u", unsigned(num));
+    sprintf(pathname, "/cache/llvm_%010u", unsigned(num));
   } while ( 0 == access(pathname, F_OK ) );
   if (-1 == ::mkdir(pathname, S_IRWXU)) {
     MakeErrMsg(ErrMsg,
--- lib/Support/Unix/PathV2.inc
+++ lib/Support/Unix/PathV2.inc
@@ -82,7 +82,7 @@
 #ifdef P_tmpdir
     (dir = P_tmpdir) ||
 #endif
-    (dir = "/tmp");
+    (dir = "/cache");
 
     result.clear();
     StringRef d(dir);
Only in xxxsrc/projects: compiler-rt
Only in xxxsrc/projects: libcxx
Only in xxxsrc/tools: clang
--- unittests/Makefile.unittest
+++ unittests/Makefile.unittest
@@ -54,9 +54,4 @@
 	$(Echo) ======= Finished Linking $(BuildMode) Unit test $(TESTNAME) \
           $(StripWarnMsg)
 
-all:: $(LLVMUnitTestExe)
-
-unitcheck:: $(LLVMUnitTestExe)
-	$(Run.Shared) $(LLVMUnitTestExe)
-
 endif
