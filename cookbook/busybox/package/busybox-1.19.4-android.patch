--- archival/dpkg.c
+++ archival/dpkg.c
@@ -801,8 +801,13 @@
 /* This could do with a cleanup */
 static void write_status_file(deb_file_t **deb_file)
 {
+#ifdef __ANDROID__
+	FILE *old_status_file = xfopen_for_read("/system/lib/dpkg/status");
+	FILE *new_status_file = xfopen_for_write("/system/lib/dpkg/status.udeb");
+#else
 	FILE *old_status_file = xfopen_for_read("/var/lib/dpkg/status");
 	FILE *new_status_file = xfopen_for_write("/var/lib/dpkg/status.udeb");
+#endif
 	char *package_name;
 	char *status_from_file;
 	char *control_buffer = NULL;
@@ -930,7 +935,11 @@
 	fclose(new_status_file);
 
 	/* Create a separate backfile to dpkg */
+#ifdef __ANDROID__
+	if (rename("/system/lib/dpkg/status", "/system/lib/dpkg/status.udeb.bak") == -1) {
+#else
 	if (rename("/var/lib/dpkg/status", "/var/lib/dpkg/status.udeb.bak") == -1) {
+#endif
 		if (errno != ENOENT)
 			bb_error_msg_and_die("can't create backup status file");
 		/* Its ok if renaming the status file fails because status
@@ -938,7 +947,11 @@
 		bb_error_msg("no status file found, creating new one");
 	}
 
+#ifdef __ANDROID__
+	xrename("/system/lib/dpkg/status.udeb", "/system/lib/dpkg/status");
+#else
 	xrename("/var/lib/dpkg/status.udeb", "/var/lib/dpkg/status");
+#endif
 }
 
 /* This function returns TRUE if the given package can satisfy a
@@ -1230,7 +1243,11 @@
 	char *script_path;
 	int result;
 
+#ifdef __ANDROID__
+	script_path = xasprintf("/system/lib/dpkg/info/%s.%s", package_name, script_type);
+#else
 	script_path = xasprintf("/var/lib/dpkg/info/%s.%s", package_name, script_type);
+#endif
 
 	/* If the file doesnt exist is isnt fatal */
 	result = access(script_path, F_OK) ? EXIT_SUCCESS : system(script_path);
@@ -1283,8 +1300,12 @@
 	/* Create a list of all /var/lib/dpkg/info/<package> files */
 	remove_files = xzalloc(sizeof(all_control_files) + sizeof(char*));
 	while (i < ARRAY_SIZE(all_control_files)) {
+#ifdef __ANDROID__
+		remove_files[i] = xasprintf("/system/lib/dpkg/info/%s.%s", package_name, all_control_files[i]);
+#else
 		remove_files[i] = xasprintf("/var/lib/dpkg/info/%s.%s",
 				package_name, all_control_files[i]);
+#endif
 		i++;
 	}
 
@@ -1364,10 +1385,18 @@
 	run_package_script_or_die(package_name, "prerm");
 
 	/* Create a list of files to remove, and a separate list of those to keep */
+#ifdef __ANDROID__
+	sprintf(list_name, "/system/lib/dpkg/info/%s.%s", package_name, "list");
+#else
 	sprintf(list_name, "/var/lib/dpkg/info/%s.%s", package_name, "list");
+#endif
 	remove_files = create_list(list_name);
 
+#ifdef __ANDROID__
+	sprintf(conffile_name, "/system/lib/dpkg/info/%s.%s", package_name, "conffiles");
+#else
 	sprintf(conffile_name, "/var/lib/dpkg/info/%s.%s", package_name, "conffiles");
+#endif
 	exclude_files = create_list(conffile_name);
 
 	/* Some directories can't be removed straight away, so do multiple passes */
@@ -1379,7 +1408,11 @@
 	/* Create a list of files in /var/lib/dpkg/info/<package>.* to keep */
 	exclude_files = xzalloc(sizeof(exclude_files[0]) * 3);
 	exclude_files[0] = xstrdup(conffile_name);
+#ifdef __ANDROID__
+	exclude_files[1] = xasprintf("/system/lib/dpkg/info/%s.%s", package_name, "postrm");
+#else
 	exclude_files[1] = xasprintf("/var/lib/dpkg/info/%s.%s", package_name, "postrm");
+#endif
 
 	/* Create a list of all /var/lib/dpkg/info/<package> files */
 	remove_files = all_control_list(package_name);
@@ -1412,7 +1445,11 @@
 	run_package_script_or_die(package_name, "prerm");
 
 	/* Create a list of files to remove */
+#ifdef __ANDROID__
+	sprintf(list_name, "/system/lib/dpkg/info/%s.%s", package_name, "list");
+#else
 	sprintf(list_name, "/var/lib/dpkg/info/%s.%s", package_name, "list");
+#endif
 	remove_files = create_list(list_name);
 
 	/* Some directories cant be removed straight away, so do multiple passes */
@@ -1425,7 +1462,11 @@
 
 	/* Delete all of them except the postrm script */
 	exclude_files = xzalloc(sizeof(exclude_files[0]) * 2);
+#ifdef __ANDROID__
+	exclude_files[0] = xasprintf("/system/lib/dpkg/info/%s.%s", package_name, "postrm");
+#else
 	exclude_files[0] = xasprintf("/var/lib/dpkg/info/%s.%s", package_name, "postrm");
+#endif
 	remove_file_array(remove_files, exclude_files);
 	free_array(exclude_files);
 
@@ -1516,7 +1557,11 @@
 	FILE *fp;
 	char *filename, *line;
 
+#ifdef __ANDROID__
+	filename = xasprintf("/system/lib/dpkg/info/%s.%s", package_name, control_name);
+#else
 	filename = xasprintf("/var/lib/dpkg/info/%s.%s", package_name, control_name);
+#endif
 	fp = fopen_for_read(filename);
 	free(filename);
 	if (fp != NULL) {
@@ -1636,7 +1681,11 @@
 	}
 
 	/* Extract control.tar.gz to /var/lib/dpkg/info/<package>.filename */
+#ifdef __ANDROID__
+	info_prefix = xasprintf("/system/lib/dpkg/info/%s.%s", package_name, "");
+#else
 	info_prefix = xasprintf("/var/lib/dpkg/info/%s.%s", package_name, "");
+#endif
 	archive_handle = init_archive_deb_ar(deb_file->filename);
 	init_archive_deb_control(archive_handle);
 
@@ -1672,7 +1721,11 @@
 	unpack_ar_archive(archive_handle);
 
 	/* Create the list file */
+#ifdef __ANDROID__
+	list_filename = xasprintf("/system/lib/dpkg/info/%s.%s", package_name, "list");
+#else
 	list_filename = xasprintf("/var/lib/dpkg/info/%s.%s", package_name, "list");
+#endif
 	out_stream = xfopen_for_write(list_filename);
 	while (archive_handle->dpkg__sub_archive->passed) {
 		/* the leading . has been stripped by data_extract_all_prefix already */
@@ -1765,7 +1818,11 @@
 	}
 
 /*	puts("(Reading database ... xxxxx files and directories installed.)"); */
+#ifdef __ANDROID__
+	index_status_file("/system/lib/dpkg/status");
+#else
 	index_status_file("/var/lib/dpkg/status");
+#endif
 
 	/* if the list action was given print the installed packages and exit */
 	if (opt & OPT_list_installed) {
--- debianutils/mktemp.c
+++ debianutils/mktemp.c
@@ -67,7 +67,11 @@
 
 	path = getenv("TMPDIR");
 	if (!path || path[0] == '\0')
+#ifdef __ANDROID__
+		path = "/data/vtmp";
+#else
 		path = "/tmp";
+#endif
 
 	/* -q is ignored */
 	opt_complementary = "?1"; /* 1 argument max */
--- e2fsprogs/fsck.c
+++ e2fsprogs/fsck.c
@@ -1059,7 +1059,11 @@
 	 * so we are scanning it anyway */
 	fstab = getenv("FSTAB_FILE");
 	if (!fstab)
+#ifdef __ANDROID__
+		fstab = "/system/etc/fstab";
+#else
 		fstab = "/etc/fstab";
+#endif
 	load_fs_info(fstab);
 
 	/*interactive = (num_devices == 1) | serialize;*/
--- e2fsprogs/old_e2fsprogs/blkid/blkidP.h
+++ e2fsprogs/old_e2fsprogs/blkid/blkidP.h
@@ -103,7 +103,11 @@
 extern char *blkid_strdup(const char *s);
 extern char *blkid_strndup(const char *s, const int length);
 
+#ifdef __ANDROID__
+#define BLKID_CACHE_FILE "/system/etc/blkid.tab"
+#else
 #define BLKID_CACHE_FILE "/etc/blkid.tab"
+#endif
 extern const char *blkid_devdirs[];
 
 #define BLKID_ERR_IO	 5
--- e2fsprogs/old_e2fsprogs/ext2fs/ismounted.c
+++ e2fsprogs/old_e2fsprogs/ext2fs/ismounted.c
@@ -168,8 +168,12 @@
 	errcode_t	retval;
 
 #ifdef DEBUG
+#ifdef __ANDROID__
+	retval = check_mntent_file("/data/vtmp/mtab", file, mount_flags, mtpt, mtlen);
+#else
 	retval = check_mntent_file("/tmp/mtab", file, mount_flags,
 				   mtpt, mtlen);
+#endif
 	if (retval == 0)
 		return 0;
 #endif /* DEBUG */
--- e2fsprogs/old_e2fsprogs/fsck.c
+++ e2fsprogs/old_e2fsprogs/fsck.c
@@ -46,8 +46,12 @@
 #include "libbb.h"
 
 #ifndef _PATH_MNTTAB
+#ifdef __ANDROID__
+#define _PATH_MNTTAB    "/system/etc/fstab"
+#else
 #define _PATH_MNTTAB    "/etc/fstab"
 #endif
+#endif
 
 /*
  * fsck.h
--- editors/diff.c
+++ editors/diff.c
@@ -707,7 +707,11 @@
 		 * When we meet non-seekable file, we must make a temp copy.
 		 */
 		if (lseek(fd, 0, SEEK_SET) == -1 && errno == ESPIPE) {
+#ifdef __ANDROID__
+			char name[] = "/data/vtmp/difXXXXXX";
+#else
 			char name[] = "/tmp/difXXXXXX";
+#endif
 			int fd_tmp = xmkstemp(name);
 
 			unlink(name);
--- include/grp_.h
+++ include/grp_.h
@@ -30,6 +30,7 @@
  * so that function calls are directed to bb_internal_XXX replacements
  */
 
+#ifndef __ANDROID__
 #define setgrent     bb_internal_setgrent
 #define endgrent     bb_internal_endgrent
 #define getgrent     bb_internal_getgrent
@@ -43,6 +44,7 @@
 #define fgetgrent_r  bb_internal_fgetgrent_r
 #define getgrouplist bb_internal_getgrouplist
 #define initgroups   bb_internal_initgroups
+#endif
 
 
 /* All function names below should be remapped by #defines above
--- include/libbb.h
+++ include/libbb.h
@@ -66,6 +66,9 @@
 #endif
 #if ENABLE_FEATURE_UTMP
 # include <utmp.h>
+#ifdef __ANDROID__
+# include <utmpx.h>
+#endif
 #endif
 #if ENABLE_LOCALE_SUPPORT
 # include <locale.h>
@@ -85,6 +88,9 @@
 #  include <shadow.h>
 # endif
 #endif
+#ifdef __ANDROID__
+#include <paths.h>
+#endif
 /* Just in case libc doesn't define some of these... */
 #ifndef _PATH_PASSWD
 #define _PATH_PASSWD  "/etc/passwd"
@@ -1672,14 +1678,22 @@
 
 /* Busybox mount uses either /proc/mounts or /etc/mtab to
  * get the list of currently mounted filesystems */
+#ifdef __ANDROID__
+#define bb_path_mtab_file IF_FEATURE_MTAB_SUPPORT("/system/etc/mtab")IF_NOT_FEATURE_MTAB_SUPPORT("/proc/mounts")
+#else
 #define bb_path_mtab_file IF_FEATURE_MTAB_SUPPORT("/etc/mtab")IF_NOT_FEATURE_MTAB_SUPPORT("/proc/mounts")
+#endif
 
 #define bb_path_passwd_file  _PATH_PASSWD
 #define bb_path_group_file   _PATH_GROUP
 #define bb_path_shadow_file  _PATH_SHADOW
 #define bb_path_gshadow_file _PATH_GSHADOW
 
+#ifdef __ANDROID__
+#define bb_path_motd_file "/system/etc/motd"
+#else
 #define bb_path_motd_file "/etc/motd"
+#endif
 
 #define bb_dev_null "/dev/null"
 extern const char bb_busybox_exec_path[];
@@ -1687,7 +1701,11 @@
  * but I want to save a few bytes here */
 extern const char bb_PATH_root_path[]; /* "PATH=/sbin:/usr/sbin:/bin:/usr/bin" */
 #define bb_default_root_path (bb_PATH_root_path + sizeof("PATH"))
+#ifdef __ANDROID__
+#define bb_default_path      (bb_PATH_root_path + sizeof("PATH=/sbin"))
+#else
 #define bb_default_path      (bb_PATH_root_path + sizeof("PATH=/sbin:/usr/sbin"))
+#endif
 
 extern const int const_int_0;
 extern const int const_int_1;
@@ -1763,9 +1781,15 @@
 # define VC_4 "/dev/tty4"
 # define VC_5 "/dev/tty5"
 # define VC_FORMAT "/dev/tty%d"
+#ifdef __ANDROID__
+# define LOOP_FORMAT "/dev/block/loop%d"
+# define LOOP_NAMESIZE (sizeof("/dev/block/loop") + sizeof(int)*3 + 1)
+# define LOOP_NAME "/dev/block/loop"
+#else
 # define LOOP_FORMAT "/dev/loop%d"
 # define LOOP_NAMESIZE (sizeof("/dev/loop") + sizeof(int)*3 + 1)
 # define LOOP_NAME "/dev/loop"
+#endif
 # define FB_0 "/dev/fb0"
 #endif
 
--- include/pwd_.h
+++ include/pwd_.h
@@ -31,6 +31,7 @@
  * so that function calls are directed to bb_internal_XXX replacements
  */
 
+#ifndef __ANDROID__
 #define setpwent    bb_internal_setpwent
 #define endpwent    bb_internal_endpwent
 #define getpwent    bb_internal_getpwent
@@ -42,6 +43,7 @@
 #define getpwuid_r  bb_internal_getpwuid_r
 #define getpwnam_r  bb_internal_getpwnam_r
 #define fgetpwent_r bb_internal_fgetpwent_r
+#endif
 
 
 /* All function names below should be remapped by #defines above
--- init/bootchartd.c
+++ init/bootchartd.c
@@ -178,7 +178,11 @@
 
 static char *make_tempdir(void)
 {
+#ifdef __ANDROID__
+	char template[] = "/data/vtmp/bootchart.XXXXXX";
+#else
 	char template[] = "/tmp/bootchart.XXXXXX";
+#endif
 	char *tempdir = xstrdup(mkdtemp(template));
 	if (!tempdir) {
 #ifdef __linux__
@@ -187,7 +191,11 @@
 		 * Since we unmount it at once, we can mount it anywhere.
 		 * Try a few locations which are likely ti exist.
 		 */
+#ifdef __ANDROID__
+		static const char dirs[] = "/mnt\0""/data/vtmp\0""/boot\0""/proc\0";
+#else
 		static const char dirs[] = "/mnt\0""/tmp\0""/boot\0""/proc\0";
+#endif
 		const char *try_dir = dirs;
 		while (mount("none", try_dir, "tmpfs", MS_SILENT, "size=16m") != 0) {
 			try_dir += strlen(try_dir) + 1;
@@ -307,7 +315,11 @@
 	fclose(header_fp);
 
 	/* Package log files */
+#ifdef __ANDROID__
+	system("tar -zcf /data/log/bootchart.tgz header *.log");
+#else
 	system("tar -zcf /var/log/bootchart.tgz header *.log"); // + $pacct
+#endif
 	/* Clean up (if we are not in detached tmpfs) */
 	if (tempdir) {
 		unlink("header");
@@ -373,9 +385,14 @@
 	sample_period_us = 200 * 1000;
 	if (ENABLE_FEATURE_BOOTCHARTD_CONFIG_FILE) {
 		char* token[2];
+#ifdef __ANDROID__
+		parser_t *parser = config_open2("/system/etc/bootchartd.conf" + 5, fopen_for_read);
+		if (!parser) parser = config_open2("/system/etc/bootchartd.conf", fopen_for_read);
+#else
 		parser_t *parser = config_open2("/etc/bootchartd.conf" + 5, fopen_for_read);
 		if (!parser)
 			parser = config_open2("/etc/bootchartd.conf", fopen_for_read);
+#endif
 		while (config_read(parser, token, 2, 0, "#=", PARSE_NORMAL & ~PARSE_COLLAPSE)) {
 			if (strcmp(token[0], "SAMPLE_PERIOD") == 0 && token[1])
 				sample_period_us = atof(token[1]) * 1000000;
--- init/init.c
+++ init/init.c
@@ -134,8 +134,12 @@
 
 /* Default sysinit script. */
 #ifndef INIT_SCRIPT
+#ifdef __ANDROID__
+#define INIT_SCRIPT  "/system/etc/init.d/rcS"
+#else
 #define INIT_SCRIPT  "/etc/init.d/rcS"
 #endif
+#endif
 
 /* Each type of actions can appear many times. They will be
  * handled in order. RESTART is an exception, only 1st is used.
@@ -635,7 +639,11 @@
 {
 #if ENABLE_FEATURE_USE_INITTAB
 	char *token[4];
+#ifdef __ANDROID__
+	parser_t *parser = config_open2("/system/etc/inittab", fopen_for_read);
+#else
 	parser_t *parser = config_open2("/etc/inittab", fopen_for_read);
+#endif
 
 	if (parser == NULL)
 #endif
@@ -884,7 +892,11 @@
 {
 	struct init_action *a, **nextp;
 
+#ifdef __ANDROID__
+	message(L_LOG, "reloading /system/etc/inittab");
+#else
 	message(L_LOG, "reloading /etc/inittab");
+#endif
 
 	/* Disable old entries */
 	for (a = init_action_list; a; a = a->next)
--- libbb/appletlib.c
+++ libbb/appletlib.c
@@ -271,7 +271,11 @@
 static void parse_config_file(void)
 {
 	/* Don't depend on the tools to combine strings. */
+#ifdef __ANDROID__
+	static const char config_file[] ALIGN1 = "/system/etc/busybox.conf";
+#else
 	static const char config_file[] ALIGN1 = "/etc/busybox.conf";
+#endif
 
 	struct suid_config_t *sct_head;
 	int applet_no;
@@ -563,8 +567,13 @@
 
 
 # if ENABLE_FEATURE_INSTALLER
+#ifdef __ANDROID__
+static const char usr_bin [] ALIGN1 = "/system/bin/";
+static const char usr_sbin[] ALIGN1 = "/system/bin/";
+#else
 static const char usr_bin [] ALIGN1 = "/usr/bin/";
 static const char usr_sbin[] ALIGN1 = "/usr/sbin/";
+#endif
 static const char *const install_dir[] = {
 	&usr_bin [8], /* "/" */
 	&usr_bin [4], /* "/bin/" */
--- libbb/messages.c
+++ libbb/messages.c
@@ -40,7 +40,11 @@
 /* util-linux manpage says /sbin:/bin:/usr/sbin:/usr/bin,
  * but I want to save a few bytes here. Check libbb.h before changing! */
 const char bb_PATH_root_path[] ALIGN1 =
+#ifdef __ANDROID__
+	"PATH=/sbin:/vendor/bin:/system/sbin:/system/bin:/data/system/bin:/sd-ext/system/bin:/system/xbin" BB_ADDITIONAL_PATH;
+#else
 	"PATH=/sbin:/usr/sbin:/bin:/usr/bin" BB_ADDITIONAL_PATH;
+#endif
 
 
 const int const_int_1 = 1;
--- libbb/rtc.c
+++ libbb/rtc.c
@@ -7,11 +7,19 @@
 #include "libbb.h"
 #include "rtc_.h"
 
+#ifdef __ANDROID__
+#if ENABLE_FEATURE_HWCLOCK_ADJTIME_FHS
+# define ADJTIME_PATH "/data/lib/hwclock/adjtime"
+#else
+# define ADJTIME_PATH "/system/etc/adjtime"
+#endif
+#else
 #if ENABLE_FEATURE_HWCLOCK_ADJTIME_FHS
 # define ADJTIME_PATH "/var/lib/hwclock/adjtime"
 #else
 # define ADJTIME_PATH "/etc/adjtime"
 #endif
+#endif
 
 int FAST_FUNC rtc_adjtime_is_utc(void)
 {
--- libbb/setup_environment.c
+++ libbb/setup_environment.c
@@ -38,7 +38,11 @@
 	/* Change the current working directory to be the home directory
 	 * of the user */
 	if (chdir(pw->pw_dir)) {
+#ifdef __ANDROID__
+		xchdir((flags & SETUP_ENV_TO_TMP) ? "/data/vtmp" : "/");
+#else
 		xchdir((flags & SETUP_ENV_TO_TMP) ? "/tmp" : "/");
+#endif
 		bb_error_msg("can't chdir to home directory '%s'", pw->pw_dir);
 	}
 
--- libbb/udp_io.c
+++ libbb/udp_io.c
@@ -7,6 +7,9 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 #include "libbb.h"
+#ifdef __ANDROID__
+#include <netinet/in.h>
+#endif
 
 /*
  * This asks kernel to let us know dst addr/port of incoming packets
--- loginutils/add-remove-shell.c
+++ loginutils/add-remove-shell.c
@@ -38,7 +38,11 @@
 
 #include "libbb.h"
 
+#ifdef __ANDROID__
+#define SHELLS_FILE "/system/etc/shells"
+#else
 #define SHELLS_FILE "/etc/shells"
+#endif
 
 #define REMOVE_SHELL (ENABLE_REMOVE_SHELL && (!ENABLE_ADD_SHELL || applet_name[0] == 'r'))
 #define ADD_SHELL    (ENABLE_ADD_SHELL && (!ENABLE_REMOVE_SHELL || applet_name[0] == 'a'))
--- loginutils/adduser.c
+++ loginutils/adduser.c
@@ -181,7 +181,11 @@
 	die_if_bad_username(pw.pw_name);
 	if (!pw.pw_dir) {
 		/* create string for $HOME if not specified already */
+#ifdef __ANDROID__
+		pw.pw_dir = xasprintf("/data/home/%s", argv[0]);
+#else
 		pw.pw_dir = xasprintf("/home/%s", argv[0]);
+#endif
 	}
 	pw.pw_passwd = (char *)"x";
 	if (opts & OPT_SYSTEM_ACCOUNT) {
@@ -189,7 +193,11 @@
 			usegroup = "nogroup";
 		}
 		if (!(opts & OPT_SHELL)) {
+#ifdef __ANDROID__
+			pw.pw_shell = (char *) "/system/bin/false";
+#else
 			pw.pw_shell = (char *) "/bin/false";
+#endif
 		}
 	}
 	pw.pw_gid = usegroup ? xgroup2gid(usegroup) : -1; /* exits on failure */
@@ -247,7 +255,11 @@
 			};
 			/* Be silent on any errors (like: no /etc/skel) */
 			logmode = LOGMODE_NONE;
+#ifdef __ANDROID__
+			copy_file("/system/etc/skel", pw.pw_dir, FILEUTILS_RECUR);
+#else
 			copy_file("/etc/skel", pw.pw_dir, FILEUTILS_RECUR);
+#endif
 			logmode = LOGMODE_STDIO;
 			chown_main(4, (char**)args);
 		}
--- loginutils/getty.c
+++ loginutils/getty.c
@@ -54,14 +54,22 @@
  * and for line editing at the same time.
  */
 #undef  _PATH_LOGIN
+#ifdef __ANDROID__
+#define _PATH_LOGIN "/system/bin/login"
+#else
 #define _PATH_LOGIN "/bin/login"
+#endif
 
 /* Displayed before the login prompt.
  * If ISSUE is not defined, getty will never display the contents of the
  * /etc/issue file. You will not want to spit out large "issue" files at the
  * wrong baud rate.
  */
+#ifdef __ANDROID__
+#define ISSUE "/system/etc/issue"
+#else
 #define ISSUE "/etc/issue"
+#endif
 
 /* Some shorthands for control characters */
 #define CTL(x)          ((x) ^ 0100)    /* Assumes ASCII dialect */
@@ -255,7 +263,11 @@
 
 	/* Set speed if it wasn't specified as "0" on command line */
 	if (speed != B0)
+#ifdef __ANDROID__
+		cfsetospeed(&G.termios, speed);
+#else
 		cfsetspeed(&G.termios, speed);
+#endif
 
 	/* Initial termios settings: 8-bit characters, raw mode, blocking i/o.
 	 * Special characters are set after we have read the login name; all
@@ -422,7 +434,11 @@
 			if (isdigit(*bp)) {
 				speed = bcode(bp);
 				if (speed > 0)
+#ifdef __ANDROID__
+					cfsetospeed(&G.termios, speed);
+#else
 					cfsetspeed(&G.termios, speed);
+#endif
 				break;
 			}
 		}
@@ -636,7 +652,11 @@
 				break;
 			/* We are here only if G.numspeed > 1 */
 			baud_index = (baud_index + 1) % G.numspeed;
+#ifdef __ANDROID__
+			cfsetospeed(&G.termios, G.speeds[baud_index]);
+#else
 			cfsetspeed(&G.termios, G.speeds[baud_index]);
+#endif
 			set_termios();
 		}
 	}
--- loginutils/login.c
+++ loginutils/login.c
@@ -50,7 +50,11 @@
 	int c;
 	int empty = 1;
 
+#ifdef __ANDROID__
+	fp = fopen_for_read("/system/etc/nologin");
+#else
 	fp = fopen_for_read("/etc/nologin");
+#endif
 	if (!fp) /* assuming it does not exist */
 		return;
 
@@ -76,8 +80,13 @@
 #if ENABLE_FEATURE_SECURETTY && !ENABLE_PAM
 static int check_securetty(void)
 {
+#ifdef __ANDROID__
+	char *buf = (char*)"/system/etc/securetty";
+	parser_t *parser = config_open2("/system/etc/securetty", fopen_for_read);
+#else
 	char *buf = (char*)"/etc/securetty"; /* any non-NULL is ok */
 	parser_t *parser = config_open2("/etc/securetty", fopen_for_read);
+#endif
 	while (config_read(parser, &buf, 1, 1, "# \t", PARSE_NORMAL)) {
 		if (strcmp(buf, short_tty) == 0)
 			break;
--- Makefile.flags
+++ Makefile.flags
@@ -97,7 +97,7 @@
 #"))
 endif
 
-LDLIBS += m crypt
+LDLIBS += m 
 
 ifeq ($(CONFIG_PAM),y)
 LDLIBS += pam pam_misc
--- miscutils/crond.c
+++ miscutils/crond.c
@@ -885,7 +885,11 @@
 	xsetenv("SHELL", DEFAULT_SHELL); /* once, for all future children */
 	crondlog(LVL8 "crond (busybox "BB_VER") started, log level %d", G.log_level);
 	rescan_crontab_dir();
+#ifdef __ANDROID__
+	write_pidfile("/data/run/crond.pid");
+#else
 	write_pidfile("/var/run/crond.pid");
+#endif
 
 	/* Main loop */
 	t2 = time(NULL);
--- miscutils/devfsd.c
+++ miscutils/devfsd.c
@@ -123,11 +123,20 @@
 
 #define BUFFER_SIZE 16384
 #define DEVFSD_VERSION "1.3.25"
+#ifdef __ANDROID__
+#define CONFIG_FILE  "/system/etc/devfsd.conf"
+#define MODPROBE		"/system/bin/modprobe"
+#else
 #define CONFIG_FILE  "/etc/devfsd.conf"
 #define MODPROBE		"/sbin/modprobe"
+#endif
 #define MODPROBE_SWITCH_1 "-k"
 #define MODPROBE_SWITCH_2 "-C"
+#ifdef __ANDROID__
+#define CONFIG_MODULES_DEVFS "/system/etc/modules.devfs"
+#else
 #define CONFIG_MODULES_DEVFS "/etc/modules.devfs"
+#endif
 #define MAX_ARGS     (6 + 1)
 #define MAX_SUBEXPR  10
 #define STRING_LENGTH 255
--- miscutils/fbsplash.c
+++ miscutils/fbsplash.c
@@ -365,7 +365,11 @@
 		if (i == 7) {
 			G.bdebug_messages = val;
 			if (G.bdebug_messages)
+#ifdef __ANDROID__
+				G.logfile_fd = xfopen_for_write("/data/vtmp/fbsplash.log");
+#else
 				G.logfile_fd = xfopen_for_write("/tmp/fbsplash.log");
+#endif
 		}
 #endif
 	}
--- miscutils/man.c
+++ miscutils/man.c
@@ -179,7 +179,11 @@
 	man_path_list = xzalloc(0x11 * sizeof(man_path_list[0]));
 	man_path_list[0] = getenv("MANPATH");
 	if (!man_path_list[0]) /* default, may be overridden by /etc/man.conf */
+#ifdef __ANDROID__
+		man_path_list[0] = (char*)"/system/share/man";
+#else
 		man_path_list[0] = (char*)"/usr/man";
+#endif
 	else
 		count_mp++;
 	pager = getenv("MANPAGER");
@@ -192,11 +196,17 @@
 	/* Parse man.conf[ig] or man_db.conf */
 	/* man version 1.6f uses man.config */
 	/* man-db implementation of man uses man_db.conf */
+#ifdef __ANDROID__
+	parser = config_open2("/system/etc/man.config", fopen_for_read);
+	if (!parser) parser = config_open2("/system/etc/man.conf", fopen_for_read);
+	if (!parser) parser = config_open2("/system/etc/man_db.conf", fopen_for_read);
+#else
 	parser = config_open2("/etc/man.config", fopen_for_read);
 	if (!parser)
 		parser = config_open2("/etc/man.conf", fopen_for_read);
 	if (!parser)
 		parser = config_open2("/etc/man_db.conf", fopen_for_read);
+#endif
 
 	while (config_read(parser, token, 2, 0, "# \t", PARSE_NORMAL)) {
 		if (!token[1])
--- miscutils/microcom.c
+++ miscutils/microcom.c
@@ -70,7 +70,11 @@
 
 	// try to create lock file in /var/lock
 	device_lock_file = (char *)bb_basename(argv[0]);
+#ifdef __ANDROID__
+	device_lock_file = xasprintf("/data/lock/LCK..%s", device_lock_file);
+#else
 	device_lock_file = xasprintf("/var/lock/LCK..%s", device_lock_file);
+#endif
 	sfd = open(device_lock_file, O_CREAT | O_WRONLY | O_TRUNC | O_EXCL, 0644);
 	if (sfd < 0) {
 		// device already locked -> bail out
@@ -108,7 +112,11 @@
 	// put device to "raw mode"
 	xget1(sfd, &tio, &tiosfd);
 	// set device speed
+#ifdef __ANDROID__
+	cfsetospeed(&tio, tty_value_to_baud(speed));
+#else
 	cfsetspeed(&tio, tty_value_to_baud(speed));
+#endif
 	if (xset1(sfd, &tio, argv[0]))
 		goto done;
 
--- modutils/modprobe.c
+++ modutils/modprobe.c
@@ -613,8 +613,13 @@
 	if (G.probes == NULL)
 		return EXIT_SUCCESS;
 
+#ifdef __ANDROID__
+	read_config("/system/etc/modprobe.conf");
+	read_config("/system/etc/modprobe.d");
+#else
 	read_config("/etc/modprobe.conf");
 	read_config("/etc/modprobe.d");
+#endif
 	if (ENABLE_FEATURE_MODUTILS_SYMBOLS && G.need_symbols)
 		read_config("modules.symbols");
 	load_modules_dep();
--- modutils/modprobe-small.c
+++ modutils/modprobe-small.c
@@ -538,7 +538,11 @@
 
 	options = NULL;
 	if (!is_rmmod) {
+#ifdef __ANDROID__
+		char *opt_filename = xasprintf("/system/etc/modules/%s", name);
+#else
 		char *opt_filename = xasprintf("/etc/modules/%s", name);
+#endif
 		options = xmalloc_open_read_close(opt_filename, NULL);
 		if (options)
 			replace(options, '\n', ' ');
--- networking/arping.c
+++ networking/arping.c
@@ -26,6 +26,9 @@
 #include <net/if.h>
 #include <netinet/ether.h>
 #include <netpacket/packet.h>
+#ifdef __ANDROID__
+#include <net/if_arp.h>
+#endif
 
 #include "libbb.h"
 
--- networking/brctl.c
+++ networking/brctl.c
@@ -67,6 +67,7 @@
 # include <linux/if_bridge.h>
 
 /* FIXME: These 4 funcs are not really clean and could be improved */
+#ifndef __ANDROID__
 static ALWAYS_INLINE void strtotimeval(struct timeval *tv,
 		const char *time_str)
 {
@@ -82,6 +83,7 @@
 	tv->tv_sec = secs;
 	tv->tv_usec = 1000000 * (secs - tv->tv_sec);
 }
+#endif
 
 static ALWAYS_INLINE unsigned long tv_to_jiffies(const struct timeval *tv)
 {
@@ -104,7 +106,11 @@
 static unsigned long str_to_jiffies(const char *time_str)
 {
 	struct timeval tv;
+#ifdef __ANDROID__
+	strtotimeval(time_str, &tv);
+#else
 	strtotimeval(&tv, time_str);
+#endif
 	return tv_to_jiffies(&tv);
 }
 
--- networking/dnsd.c
+++ networking/dnsd.c
@@ -492,7 +492,11 @@
 int dnsd_main(int argc UNUSED_PARAM, char **argv)
 {
 	const char *listen_interface = "0.0.0.0";
+#ifdef __ANDROID__
+	const char *fileconf = "/system/etc/dnsd.conf";
+#else
 	const char *fileconf = "/etc/dnsd.conf";
+#endif
 	struct dns_entry *conf_data;
 	uint32_t conf_ttl = DEFAULT_TTL;
 	char *sttl, *sport;
--- networking/httpd.c
+++ networking/httpd.c
@@ -140,7 +140,11 @@
 
 #define HEADER_READ_TIMEOUT 60
 
+#ifdef __ANDROID__
+static const char DEFAULT_PATH_HTTPD_CONF[] ALIGN1 = "/system/etc";
+#else
 static const char DEFAULT_PATH_HTTPD_CONF[] ALIGN1 = "/etc";
+#endif
 static const char HTTPD_CONF[] ALIGN1 = "httpd.conf";
 static const char HTTP_200[] ALIGN1 = "HTTP/1.0 200 OK\r\n";
 static const char index_html[] ALIGN1 = "index.html";
--- networking/ifupdown.c
+++ networking/ifupdown.c
@@ -526,17 +526,28 @@
 		"dhcpcd -k %iface%",
 	},
 	{ "dhclient",
+#ifdef __ANDROID__
+		"dhclient -pf /data/run/dhclient.%iface%.pid %iface%",
+		"kill -9 `cat /data/run/dhclient.%iface%.pid` 2>/dev/null",
+#else
 		"dhclient -pf /var/run/dhclient.%iface%.pid %iface%",
 		"kill -9 `cat /var/run/dhclient.%iface%.pid` 2>/dev/null",
+#endif
 	},
 	{ "pump",
 		"pump -i %iface%[[ -h %hostname%]][[ -l %leasehours%]]",
 		"pump -i %iface% -k",
 	},
 	{ "udhcpc",
+#ifdef __ANDROID__
+		"udhcpc " UDHCPC_CMD_OPTIONS " -p /data/run/udhcpc.%iface%.pid -i %iface%[[ -H %hostname%]][[ -c %client%]]"
+				"[[ -s %script%]][[ %udhcpc_opts%]]",
+		"kill `cat /data/run/udhcpc.%iface%.pid` 2>/dev/null",
+#else
 		"udhcpc " UDHCPC_CMD_OPTIONS " -p /var/run/udhcpc.%iface%.pid -i %iface%[[ -H %hostname%]][[ -c %client%]]"
 				"[[ -s %script%]][[ %udhcpc_opts%]]",
 		"kill `cat /var/run/udhcpc.%iface%.pid` 2>/dev/null",
+#endif
 	},
 };
 # endif /* FEATURE_IFUPDOWN_EXTERNAL_DHCPC */
@@ -573,7 +584,11 @@
 	if (!execute("ifconfig %iface%[[ hw %hwaddress%]] up", ifd, exec))
 		return 0;
 #  endif
+#ifdef __ANDROID__
+	return execute("udhcpc " UDHCPC_CMD_OPTIONS " -p /data/run/udhcpc.%iface%.pid "
+#else
 	return execute("udhcpc " UDHCPC_CMD_OPTIONS " -p /var/run/udhcpc.%iface%.pid "
+#endif
 			"-i %iface%[[ -H %hostname%]][[ -c %client%]][[ -s %script%]][[ %udhcpc_opts%]]",
 			ifd, exec);
 }
@@ -613,8 +628,13 @@
 {
 	int result;
 	result = execute(
+#ifdef __ANDROID__
+		"test -f /data/run/udhcpc.%iface%.pid && "
+		"kill `cat /data/run/udhcpc.%iface%.pid` 2>/dev/null",
+#else
 		"test -f /var/run/udhcpc.%iface%.pid && "
 		"kill `cat /var/run/udhcpc.%iface%.pid` 2>/dev/null",
+#endif
 		ifd, exec);
 	/* Also bring the hardware interface down since
 	   killing the dhcp client alone doesn't do it.
@@ -658,13 +678,21 @@
 static int FAST_FUNC wvdial_up(struct interface_defn_t *ifd, execfn *exec)
 {
 	return execute("start-stop-daemon --start -x wvdial "
+#ifdef __ANDROID__
+		"-p /data/run/wvdial.%iface% -b -m --[[ %provider%]]", ifd, exec);
+#else
 		"-p /var/run/wvdial.%iface% -b -m --[[ %provider%]]", ifd, exec);
+#endif
 }
 
 static int FAST_FUNC wvdial_down(struct interface_defn_t *ifd, execfn *exec)
 {
 	return execute("start-stop-daemon --stop -x wvdial "
+#ifdef __ANDROID__
+			"-p /data/run/wvdial.%iface% -s 2", ifd, exec);
+#else
 			"-p /var/run/wvdial.%iface% -s 2", ifd, exec);
+#endif
 }
 
 static const struct method_t methods[] = {
@@ -1039,7 +1067,11 @@
 		}
 	}
 
+#ifdef __ANDROID__
+	buf = xasprintf("run-parts /system/etc/network/if-%s.d", opt);
+#else
 	buf = xasprintf("run-parts /etc/network/if-%s.d", opt);
+#endif
 	/* heh, we don't bother free'ing it */
 	return doit(buf);
 }
@@ -1185,7 +1217,11 @@
 	int (*cmds)(struct interface_defn_t *);
 	struct interfaces_file_t *defn;
 	llist_t *target_list = NULL;
+#ifdef __ANDROID__
+	const char *interfaces = "/system/etc/network/interfaces";
+#else
 	const char *interfaces = "/etc/network/interfaces";
+#endif
 	bool any_failures = 0;
 
 	INIT_G();
--- networking/inetd.c
+++ networking/inetd.c
@@ -165,6 +165,9 @@
 //usage:     "\n		(default: 0 - disabled)"
 
 #include <syslog.h>
+#ifdef __ANDROID__
+#include <sys/socket.h>
+#endif
 #include <sys/un.h>
 
 #include "libbb.h"
@@ -184,7 +187,11 @@
 #define ENABLE_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN 0
 #endif
 
+#ifdef __ANDROID__
+#define _PATH_INETDPID  "/data/run/inetd.pid"
+#else
 #define _PATH_INETDPID  "/var/run/inetd.pid"
+#endif
 
 #define CNT_INTERVAL    60      /* servers in CNT_INTERVAL sec. */
 #define RETRYTIME       60      /* retry after bind or server fail */
@@ -351,11 +358,15 @@
 #define ring            (G.ring           )
 #define allsock         (G.allsock        )
 #define line            (G.line           )
+#ifdef __ANDROID__
+#define INIT_G() do { rlim_ofile_cur = OPEN_MAX; global_queuelen = 128; config_filename = "/system/etc/inetd.conf"; } while (0)
+#else
 #define INIT_G() do { \
 	rlim_ofile_cur = OPEN_MAX; \
 	global_queuelen = 128; \
 	config_filename = "/etc/inetd.conf"; \
 } while (0)
+#endif
 
 static void maybe_close(int fd)
 {
--- networking/libiproute/rt_names.c
+++ networking/libiproute/rt_names.c
@@ -85,7 +85,11 @@
 		return;
 	rtnl_rtprot_tab = xzalloc(sizeof(*rtnl_rtprot_tab));
 	memcpy(rtnl_rtprot_tab->tab, init_tab, sizeof(init_tab));
+#ifdef __ANDROID__
+	rtnl_tab_initialize("/system/etc/iproute2/rt_protos", rtnl_rtprot_tab->tab);
+#else
 	rtnl_tab_initialize("/etc/iproute2/rt_protos", rtnl_rtprot_tab->tab);
+#endif
 }
 
 const char* FAST_FUNC rtnl_rtprot_n2a(int id, char *buf)
@@ -123,7 +127,11 @@
 	rtnl_rtscope_tab->tab[254] = "host";
 	rtnl_rtscope_tab->tab[253] = "link";
 	rtnl_rtscope_tab->tab[200] = "site";
+#ifdef __ANDROID__
+	rtnl_tab_initialize("/system/etc/iproute2/rt_scopes", rtnl_rtscope_tab->tab);
+#else
 	rtnl_tab_initialize("/etc/iproute2/rt_scopes", rtnl_rtscope_tab->tab);
+#endif
 }
 
 const char* FAST_FUNC rtnl_rtscope_n2a(int id, char *buf)
@@ -156,7 +164,11 @@
 	if (rtnl_rtrealm_tab) return;
 	rtnl_rtrealm_tab = xzalloc(sizeof(*rtnl_rtrealm_tab));
 	rtnl_rtrealm_tab->tab[0] = "unknown";
+#ifdef __ANDROID__
+	rtnl_tab_initialize("/system/etc/iproute2/rt_realms", rtnl_rtrealm_tab->tab);
+#else
 	rtnl_tab_initialize("/etc/iproute2/rt_realms", rtnl_rtrealm_tab->tab);
+#endif
 }
 
 int FAST_FUNC rtnl_rtrealm_a2n(uint32_t *id, char *arg)
@@ -191,7 +203,11 @@
 	if (rtnl_rtdsfield_tab) return;
 	rtnl_rtdsfield_tab = xzalloc(sizeof(*rtnl_rtdsfield_tab));
 	rtnl_rtdsfield_tab->tab[0] = "0";
+#ifdef __ANDROID__
+	rtnl_tab_initialize("/system/etc/iproute2/rt_dsfield", rtnl_rtdsfield_tab->tab);
+#else
 	rtnl_tab_initialize("/etc/iproute2/rt_dsfield", rtnl_rtdsfield_tab->tab);
+#endif
 }
 
 const char* FAST_FUNC rtnl_dsfield_n2a(int id, char *buf)
@@ -228,7 +244,11 @@
 	rtnl_rttable_tab->tab[255] = "local";
 	rtnl_rttable_tab->tab[254] = "main";
 	rtnl_rttable_tab->tab[253] = "default";
+#ifdef __ANDROID__
+	rtnl_tab_initialize("/system/etc/iproute2/rt_tables", rtnl_rttable_tab->tab);
+#else
 	rtnl_tab_initialize("/etc/iproute2/rt_tables", rtnl_rttable_tab->tab);
+#endif
 }
 
 const char* FAST_FUNC rtnl_rttable_n2a(int id, char *buf)
--- networking/nameif.c
+++ networking/nameif.c
@@ -219,7 +219,11 @@
 int nameif_main(int argc UNUSED_PARAM, char **argv)
 {
 	ethtable_t *clist = NULL;
+#ifdef __ANDROID__
+	const char *fname = "/system/etc/mactab";
+#else
 	const char *fname = "/etc/mactab";
+#endif
 	int ctl_sk;
 	ethtable_t *ch;
 	parser_t *parser;
--- networking/nslookup.c
+++ networking/nslookup.c
@@ -27,6 +27,18 @@
 
 #include <resolv.h>
 #include "libbb.h"
+#ifdef __ANDROID__
+# include <netinet/in.h>
+# ifdef ENABLE_FEATURE_IPV6
+#  include <netinet/in6.h>
+# endif
+# include <arpa_nameser.h>
+# include <resolv_private.h>
+# include <resolv.h>
+# undef _res
+struct __res_state _nres;
+# define _res _nres
+#endif
 
 /*
  * I'm only implementing non-interactive mode;
@@ -119,7 +131,7 @@
 	char *server;
 	struct sockaddr *sa;
 
-#if ENABLE_FEATURE_IPV6
+#if ENABLE_FEATURE_IPV6 && !defined(__ANDROID__)
 	sa = (struct sockaddr*)_res._u._ext.nsaddrs[0];
 	if (!sa)
 #endif
@@ -146,7 +158,7 @@
 		/* struct copy */
 		_res.nsaddr_list[0] = lsa->u.sin;
 	}
-#if ENABLE_FEATURE_IPV6
+#if ENABLE_FEATURE_IPV6 && !defined(__ANDROID__)
 	/* Hoped libc can cope with IPv4 address there too.
 	 * No such luck, glibc 2.4 segfaults even with IPv6,
 	 * maybe I misunderstand how to make glibc use IPv6 addr?
--- networking/telnetd.c
+++ networking/telnetd.c
@@ -83,10 +83,14 @@
 	int maxfd;
 } FIX_ALIASING;
 #define G (*(struct globals*)&bb_common_bufsiz1)
+#ifdef __ANDROID__
+#define INIT_G() do { G.loginpath = "/system/bin/login"; G.issuefile = "/system/etc/issue.net"; } while (0)
+#else
 #define INIT_G() do { \
 	G.loginpath = "/bin/login"; \
 	G.issuefile = "/etc/issue.net"; \
 } while (0)
+#endif
 
 
 /*
--- networking/udhcp/dhcpd.h
+++ networking/udhcp/dhcpd.h
@@ -12,7 +12,11 @@
 #define DEFAULT_LEASE_TIME      (60*60*24 * 10)
 #define LEASES_FILE             CONFIG_DHCPD_LEASES_FILE
 /* Where to find the DHCP server configuration file */
+#ifdef __ANDROID__
+#define DHCPD_CONF_FILE         "/system/etc/udhcpd.conf"
+#else
 #define DHCPD_CONF_FILE         "/etc/udhcpd.conf"
+#endif
 
 
 struct static_lease {
--- networking/udhcp/files.c
+++ networking/udhcp/files.c
@@ -75,7 +75,11 @@
 	{"offer_time"   , read_u32        , &server_config.offer_time   , "60"},
 	{"min_lease"    , read_u32        , &server_config.min_lease_sec, "60"},
 	{"lease_file"   , read_str        , &server_config.lease_file   , LEASES_FILE},
+#ifdef __ANDROID__
+	{"pidfile"	, read_str	, &server_config.pidfile	, "/data/run/udhcpd.pid"},
+#else
 	{"pidfile"      , read_str        , &server_config.pidfile      , "/var/run/udhcpd.pid"},
+#endif
 	{"siaddr"       , udhcp_str2nip   , &server_config.siaddr_nip   , "0.0.0.0"},
 	/* keywords with no defaults must be last! */
 	{"option"       , udhcp_str2optset, &server_config.options      , ""},
--- networking/zcip.c
+++ networking/zcip.c
@@ -43,6 +43,10 @@
 
 #include <syslog.h>
 
+#ifdef __ANDROID__
+#include <netinet/if_ether.h>
+#endif
+
 /* We don't need more than 32 bits of the counter */
 #define MONOTONIC_US() ((unsigned)monotonic_us())
 
--- printutils/lpr.c
+++ printutils/lpr.c
@@ -77,7 +77,11 @@
 		LPQ_DELETE      = 1 << 3, // -d: delete job(s)
 		LPQ_FORCE       = 1 << 4, // -f: force waiting job(s) to be printed
 	};
+#ifdef __ANDROID__
+	char tempfile[sizeof("/data/vtmp/lprXXXXXX")];
+#else
 	char tempfile[sizeof("/tmp/lprXXXXXX")];
+#endif
 	const char *job_title;
 	const char *printer_class = "";   // printer class, max 32 char
 	const char *queue;                // name of printer queue
@@ -177,7 +181,11 @@
 
 		// if data file is stdin, we need to dump it first
 		if (LONE_DASH(*argv)) {
+#ifdef __ANDROID__
+			strcpy(tempfile, "/data/vtmp/lprXXXXXX");
+#else
 			strcpy(tempfile, "/tmp/lprXXXXXX");
+#endif
 			dfd = xmkstemp(tempfile);
 			bb_copyfd_eof(STDIN_FILENO, dfd);
 			xlseek(dfd, 0, SEEK_SET);
--- procps/sysctl.c
+++ procps/sysctl.c
@@ -257,7 +257,11 @@
 	if (opt & FLAG_PRELOAD_FILE) {
 		option_mask32 |= FLAG_WRITE;
 		/* xchdir("/proc/sys") is inside */
+#ifdef __ANDROID__
+		return sysctl_handle_preload_file(*argv ? *argv : "/system/etc/sysctl.conf");
+#else
 		return sysctl_handle_preload_file(*argv ? *argv : "/etc/sysctl.conf");
+#endif
 	}
 	xchdir("/proc/sys");
 	/* xchroot(".") - if you are paranoid */
--- selinux/sestatus.c
+++ selinux/sestatus.c
@@ -61,7 +61,11 @@
 
 	pc[0] = fc[0] = NULL;
 
+#ifdef __ANDROID__
+	parser = config_open("/system/etc/sestatus.conf");
+#else
 	parser = config_open("/etc/sestatus.conf");
+#endif
 	while (config_read(parser, &buf, 1, 1, "# \t", PARSE_NORMAL)) {
 		if (strcmp(buf, "[process]") == 0) {
 			section = 1;
--- shell/ash.c
+++ shell/ash.c
@@ -13162,7 +13162,11 @@
 		isloginsh = 1;
 	if (isloginsh) {
 		state = 1;
+#ifdef __ANDROID__
+		read_profile("/system/etc/profile");
+#else
 		read_profile("/etc/profile");
+#endif
  state1:
 		state = 2;
 		read_profile(".profile");
--- shell/hush.c
+++ shell/hush.c
@@ -8003,8 +8003,13 @@
 	/* If we are login shell... */
 	if (flags & OPT_login) {
 		FILE *input;
+#ifdef __ANDROID__
+		debug_printf("sourcing /system/etc/profile\n");
+		input = fopen_for_read("/system/etc/profile");
+#else
 		debug_printf("sourcing /etc/profile\n");
 		input = fopen_for_read("/etc/profile");
+#endif
 		if (input != NULL) {
 			close_on_exec_on(fileno(input));
 			install_special_sighandlers();
--- sysklogd/syslogd.c
+++ sysklogd/syslogd.c
@@ -172,7 +172,11 @@
 
 static const struct init_globals init_data = {
 	.logFile = {
+#ifdef __ANDROID__
+		.path = "/data/log/messages",
+#else
 		.path = "/var/log/messages",
+#endif
 		.fd = -1,
 	},
 #ifdef SYSLOGD_MARK
@@ -277,7 +281,11 @@
 	char *tok[3];
 	parser_t *parser;
 
+#ifdef __ANDROID__
+	parser = config_open2(file ? file : "/system/etc/syslog.conf",
+#else
 	parser = config_open2(file ? file : "/etc/syslog.conf",
+#endif
 				file ? xfopen_for_read : fopen_for_read);
 	if (!parser)
 		/* didn't find default /etc/syslog.conf */
@@ -980,7 +988,11 @@
 		bb_daemonize_or_rexec(DAEMON_CHDIR_ROOT, argv);
 	}
 	//umask(0); - why??
+#ifdef __ANDROID__
+	write_pidfile("/data/run/syslogd.pid");
+#else
 	write_pidfile("/var/run/syslogd.pid");
+#endif
 	do_syslogd();
 	/* return EXIT_SUCCESS; */
 }
--- util-linux/acpid.c
+++ util-linux/acpid.c
@@ -229,6 +229,16 @@
 	int nfd;
 	int opts;
 	struct pollfd *pfd;
+#ifdef __ANDROID__
+	const char *opt_dir = "/system/etc/acpi";
+	const char *opt_input = "/dev/input/event";
+	const char *opt_logfile = "/data/log/acpid.log";
+	const char *opt_action = "/system/etc/acpid.conf";
+	const char *opt_map = "/system/etc/acpi.map";
+#if ENABLE_FEATURE_PIDFILE
+	const char *opt_pidfile = "/data/run/acpid.pid";
+#endif
+#else
 	const char *opt_dir = "/etc/acpi";
 	const char *opt_input = "/dev/input/event";
 	const char *opt_logfile = "/var/log/acpid.log";
@@ -237,6 +247,7 @@
 #if ENABLE_FEATURE_PIDFILE
 	const char *opt_pidfile = "/var/run/acpid.pid";
 #endif
+#endif
 
 	INIT_G();
 
--- util-linux/fbset.c
+++ util-linux/fbset.c
@@ -30,7 +30,11 @@
 #include "libbb.h"
 
 #define DEFAULTFBDEV  FB_0
+#ifdef __ANDROID__
+#define DEFAULTFBMODE "/system/etc/fb.modes"
+#else
 #define DEFAULTFBMODE "/etc/fb.modes"
+#endif
 
 /* Stuff stolen from the kernel's fb.h */
 #define FB_ACTIVATE_ALL 64
--- util-linux/mdev.c
+++ util-linux/mdev.c
@@ -199,7 +199,11 @@
 
 	/* If we have config file, look up user settings */
 	if (ENABLE_FEATURE_MDEV_CONF)
+#ifdef __ANDROID__
+		parser = config_open2("/system/etc/mdev.conf", fopen_for_read);
+#else
 		parser = config_open2("/etc/mdev.conf", fopen_for_read);
+#endif
 
 	do {
 		int keep_matching;
--- util-linux/mount.c
+++ util-linux/mount.c
@@ -507,7 +507,11 @@
 static llist_t *get_block_backed_filesystems(void)
 {
 	static const char filesystems[2][sizeof("/proc/filesystems")] = {
+#ifdef __ANDROID__
+		"/system/etc/filesystems",
+#else
 		"/etc/filesystems",
+#endif
 		"/proc/filesystems",
 	};
 	char *fs, *buf;
@@ -2026,7 +2030,11 @@
 	}
 
 	// Open either fstab or mtab
+#ifdef __ANDROID__
+	fstabname = "/system/etc/fstab";
+#else
 	fstabname = "/etc/fstab";
+#endif
 	if (i & MS_REMOUNT) {
 		// WARNING. I am not sure this matches util-linux's
 		// behavior. It's possible util-linux does not
--- util-linux/swaponoff.c
+++ util-linux/swaponoff.c
@@ -83,9 +83,14 @@
 	FILE *f;
 	int err;
 
+#ifdef __ANDROID__
+	f = setmntent("/system/etc/fstab", "r");
+	if (f == NULL) bb_perror_msg_and_die("/system/etc/fstab");
+#else
 	f = setmntent("/etc/fstab", "r");
 	if (f == NULL)
 		bb_perror_msg_and_die("/etc/fstab");
+#endif
 
 	err = 0;
 	while ((m = getmntent(f)) != NULL) {
